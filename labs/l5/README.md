# This is for non-programming exercise.

## Layer programming

1. In my implementation, the three layers are:
    1. user interface
    2. sorting and other operations
    3. list data structure

2. I reorganized the code in ./h3ex2/ directory and add header files. The file structure now is:
    1. `ui.c/h`: user interface
    2. `sort.c/h`: sorting and other operations
    3. `list.c/h`: list data structure
    4. `cmd_main.c`: main function for cmd interface
    5. `menu_main.c`: main function for menu interface
    Note: 
    1. the ex2.c is the original file.
    2. To compile and run, use the following command:
        ```bash
        cd /l5/h3ex2
        make
        ./ex2_cmd # for cmd interface
        ./ex2_menu # for menu interface
        ```

## Libraries

1. Four stages:
    1. **Preprocessing**:
    - In this stage, the source code is preprocessed to handle directives and macros. The preprocessor takes care of tasks like including header files (`#include`), macro expansion, conditional compilation (`#ifdef`, `#ifndef`, `#if`, etc.), and removing comments.
    - The output of the preprocessing stage is an intermediate file that contains the source code after preprocessing. This file is often referred to as a "translation unit."

    2. **Compilation**:
    - In the compilation stage, the preprocessed source code is translated into assembly language or an intermediate representation.
    - The compiler analyzes the code for syntax and semantic errors, performs optimizations, and generates assembly language or intermediate code. The output is often an object file containing machine code instructions or equivalent representation.

    3. **Assembly**:
    - The assembly stage takes the assembly language or intermediate code generated by the compiler and translates it into machine code specific to the target architecture.
    - The output of this stage is an object file that contains machine code instructions and may also include relocation information, which specifies how the code should be linked with other object files.

    4. **Linking**:
    - In the linking stage, the linker combines multiple object files, resolves references between them, and generates an executable program.
    - The linker resolves references to external symbols and libraries, ensuring that functions and data from other object files or libraries are correctly connected.
    - The output of this stage is the final executable program that can be run on the target system.

2. static library vs. dynamic library: static libraries are locked in to the program when being compiled; dynamic
libraries exist as separate files outside the binary file
    1. static library:
    - A static library is a collection of object files that are linked with the program at compile time. The linker copies the object files from the library into the executable file, so the library code becomes part of the executable.
    - The advantage of static libraries is that they are easy to use and do not require any additional steps to run the program. However, they can increase the size of the executable file and may cause problems if multiple programs use the same library but require different versions of it.
    2. dynamic library:
    - A dynamic library is a collection of object files that are linked with the program at run time. The linker does not copy the object files from the library into the executable file; instead, it creates a reference to the library in the executable file.
    - The advantage of dynamic libraries is that they can be shared between multiple programs, reducing the size of each executable file. However, they require additional steps to run the program, such as setting the `LD_LIBRARY_PATH` environment variable or using the `-rpath` linker option.

3. Generating two static libraries for the lowest two layers in the previous program and compile:

```bash
gcc -c list.c -o list.o
ar rcs list.a list.o
gcc -c sort.c -o sort.o
ar rcs sort.a sort.o
gcc -c ui.c -o ui.o
gcc -c cmd_main.c -o cmd_main.o
gcc -o ex2_cmd cmd_main.o ui.o list.a sort.a # for cmd interface
```

4. Genrating two dynamic libraries for the lowest two layers in the previous program and compile and run:

```bash
gcc -c *.c -fpic
gcc -shared list.o -o list.so
gcc -shared sort.o -o sort.so
gcc -c ui.c -o ui.o
gcc -c cmd_main.c -o cmd_main.o
gcc -c menu_main.c -o menu_main.o
gcc -o ex2_menu menu_main.o ui.o list.so sort.so
export LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH
./ex2_menu
```

5. Library vs. API: a library is a collection of functions that can be used by other programs; an API is a set of rules and specifications that programs must follow to communicate with each other.


