# Non-programming exercises

## Ex1 Page Replacement Algorithm

1. **Explain the content of the new table entries if a clock interrupt occurs at tick 10.**

   Clean the reference bit in the nearest two tick. The new table entries are:

   | Page | Time Stamp | Present | Referenced | Modified |
   | ---- | ---------- | ------- | ---------- | -------- |
   | 0    | 6          | 1       | 0          | 1        |
   | 1    | 9          | 1       | 0          | 0        |
   | 2    | 9          | 1       | 0          | 1        |
   | 3    | 7          | 1       | 0          | 0        |
   | 4    | 4          | 0       | 0          | 0        |

2. 

   | Page | Time Stamp | Present | Referenced | Modified |
   | ---- | ---------- | ------- | ---------- | -------- |
   | 0    | 6          | 1       | 0          | 1        |
   | 1    | 9          | 1       | 0          | 0        |
   | 2    | 9          | 1       | 0          | 1        |
   | 3    | 7          | 0       | 0          | 0        |
   | 4    | 10         | 1       | 1          | 0        |

## Ex2 Minix

1. **In which files are:** 

   **a) the constants with number and name for the system calls?**

   `/include/minix/callnr.h`

   ```shell
    head -n 7 include/minix/callnr.h
   ```

   ```c
    #define NCALLS           114    /* number of system calls allowed */

    /* In case it isn't obvious enough: this list is sorted numerically. */
    #define EXIT               1 
    #define FORK               2 
    #define READ               3 
    #define WRITE              4 
   /* omit */
   ```

   **b) the names of the system call routines?**

   `/servers/*/table.c`

    ```shell
        find ./servers/ -name 'table.c'
    ```

    ```shell
        ./servers/iso9660fs/table.c
        ./servers/pfs/table.c
        ./servers/pm/table.c
        ./servers/vfs/table.c
        ./servers/rs/table.c
        ./servers/ext2/table.c
        ./servers/mfs/table.c
    ```

   **c) the prototypes of the system call routines?**

   `/servers/*/proto.h`

   ```shell
        find ./servers/ -name 'proto.h'
    ```

    ```shell
        ./servers/sched/proto.h
        ./servers/iso9660fs/proto.h
        ./servers/lwip/proto.h
        ./servers/pfs/proto.h
        ./servers/pm/proto.h
        ./servers/vfs/proto.h
        ./servers/is/proto.h
        ./servers/devman/proto.h
        ./servers/inet/proto.h
        ./servers/rs/proto.h
        ./servers/procfs/proto.h
        ./servers/ext2/proto.h
        ./servers/ds/proto.h
        ./servers/vm/proto.h
        ./servers/mfs/proto.h
    ```

   **d) the system calls of type "signal" coded?**

   `/servers/pm/signal.c`

   ```c
   /* This file handles signals, which are asynchronous events and are generally
    * a messy and unpleasant business.  Signals can be generated by the KILL
    * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).
    * In all cases control eventually passes to check_sig() to see which processes
    * can be signaled.  The actual signaling is done by sig_proc().
    *
    * The entry points into this file are:
    *   do_sigaction:	perform the SIGACTION system call
    *   do_sigpending:	perform the SIGPENDING system call
    *   do_sigprocmask:	perform the SIGPROCMASK system call
    *   do_sigreturn:	perform the SIGRETURN system call
    *   do_sigsuspend:	perform the SIGSUSPEND system call
    *   do_kill:		perform the KILL system call
    *   do_pause:		perform the PAUSE system call
    *   process_ksig:	process a signal an behalf of the kernel
    *   sig_proc:		interrupt or terminate a signaled process
    *   check_sig:		check which processes to signal with sig_proc()
    *   check_pending:	check if a pending signal can now be delivered
    *   restart_sigs: 	restart signal work after finishing a VFS call
    */
   ```

2. **What problems arise when trying to implement a system call `int getchpids(int n, pid_t *childpid)` which "writes" the pids of up to n children of the current process into `*childpid`?**

there may be some memory accessing issues since getchpids is called from user space.

3. **Write a "sub-system call" `int getnchpid(int n, pid_t childpid)` which retrieves the n-th child process.**

    ```c
        #include <unistd.h>
        #include "mproc.h"
        /* Global error number set for failed system calls. */
        #define OK 0

        int getnchpid(int n, pid_t *childpid) {
            register struct mproc *rmc; /* pointer to child */
            if (childpid == NULL) return -1;
            if (n > NR_PROCS) return -1;
            rmc = &mproc[n];
            if (rmc->mp_parent != who_p) return -1;
            *childpid = rmc->mp_pid;
            return OK;
        }
   ```

4. **Using the previous sub-system call, implement the original `getchpids` system call. The returned `int` value corresponds to the number of pids in `*childpid`, or `-1` on an error.** 

    ```c
        #include <unistd.h>
        #include "mproc.h"

        #define OK 0

        int getchpids(int n, pid_t *childpid) {
            int i;
            for (i = 0; i < n; i++) {
                if (getnchpid(i, childpid + i) != OK) return -1;
            }
            return i;
        }
    ```
    
5. **Write a short program that demonstrate the previous system calls**.

    ```c
        #include <unistd.h>
        #include <stdio.h>

        int main() {
            pid_t childpid[10];
            int childNum = 10;
            pid_t childpidRef[10];
            
            for(int i = 0; i < childNum; i++){
                pid_t pid = fork();
                if (pid == 0) break;
                childpidRef[i] = pid;
            }
            
            getchpids(childNum, childpid);
            
            for(int i = 0; i < childNum; i++) {
                if(childpidRef[i] != childpid[i]) {
                    printf("%dth pid is wrong!",i);
                    return -1;
                }
            }

            return 0;
        }
    ```

6. **The above strategy solves the initial problem through the introduction of a sub-system call.**

   **a) What are the drawbacks and benefits of this solution?**

   - Benefits: Safe and easy.
   - Drawbacks: Slow because of calls for sub-system call.

   **b)** **Can you think of any alternative approach? If yes, provide basic details, without any implementation.**

   We may pass the `childpid` array to sub-system call and let the sub-system call handle the whole job.

## Ex3 Research

The ext2 (second extended file system) is a file system specifically designed for the Linux kernel. Initially developed by French software developer Rémy Card in 1993, ext2 was created as a replacement for the extended file system (ext) and drew its design principles from the Berkeley Fast File System from BSD, making it the first commercial-grade filesystem for Linux. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

Ext2, notable for its simplicity and efficiency, supports larger file and partition sizes than its predecessor, along with basic access control, but lacks journaling. Its simplicity makes it particularly suitable for systems where performance is a priority. [\[source\]](https://phoenixnap.com/kb/ext2-ext3-ext4)

In terms of structure, ext2 starts with a superblock located at a byte offset of 1024 from the start of the volume, followed by a Block Group Descriptor Table that gives an overview of how the volume is partitioned. [\[source\]](https://www.nongnu.org/ext2-doc/ext2.html)

The space in ext2 is divided into blocks grouped into block groups. Each block group contains a copy of the superblock and block group descriptor table, as well as a block bitmap, an inode bitmap, an inode table, and the actual data blocks. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

Every file or directory in ext2 is represented by an inode, which includes information about the file's size, permissions, ownership, and disk location. Inodes in ext2 have a structure that includes 15 pointers to direct and indirect data blocks. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

Directories in ext2 are essentially lists of directory entries that associate filenames with inode numbers. For larger directories, however, this linear search approach can be inefficient, a limitation addressed in the subsequent ext3 filesystem. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

When creating new files or directories, ext2 attempts to allocate them in the same block group as their parent directory to minimize disk seek times and enhance performance. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

The limits of ext2 under Linux vary based on block size, with maximum file sizes ranging from 16 GiB to 2 TiB and maximum filesystem sizes ranging from 4 TiB to 32 TiB. These limits are determined by the file system's data format and the operating system's kernel, particularly the architecture's page size. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

An interesting aspect of ext2 is its extensibility. Over time, it served as a testbed for new extensions to the VFS API, such as the POSIX draft ACL proposal and extended attribute proposal. It also became the default filesystem for several Linux distributions, including Debian and Red Hat Linux, until it was superseded by ext3 and later ext4. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2) Despite newer filesystems, ext2 remains recommended for flash-based storage media like SD cards and USB flash drives due to its lack of journaling, which enhances performance and minimizes wear on these devices. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

Additionally, ext2 has seen modifications like e2compr, a patch supporting file compression and decompression within the filesystem, without requiring user application support. This feature compresses only regular files and not administrative data like the superblock or inodes, to ensure system stability and safety. [\[source\]](https://en.wikipedia.org/wiki/Ext2#ext2)

## Ex. 4 - Simple Questions

1. **‌If a page is shared between two processes, is it possible that the page is read-only for one process and read-write for the other? Why or why not?**

When a page is shared between processes, it is typically mapped into the address space of each process. The operating system can then set different permissions for each process's mapping of the page. For example, if the page is read-only for one process, then any attempt by that process to write to the page will result in a fault. This helps to protect the integrity of the data in the page.

2. **When both paging and segmentation are being used, first the segment descriptor is found and then the page descriptor. Does the TLB also need a two-levels lookup?**

Whether or not the TLB needs a two-level lookup depends on the specific implementation of the TLB and the memory management unit (MMU). In general, however, the TLB will need to have some way of handling both segment descriptors and page descriptors.

There are two main approaches to handling segment descriptors and page descriptors in a TLB:

One-level TLB: In a one-level TLB, the TLB is organized as a single hash table that stores both segment descriptors and page descriptors. This approach is simpler to implement, but it can be less efficient because the TLB must search through a larger number of entries to find a match.

Two-level TLB: In a two-level TLB, the TLB is organized as two hash tables. The first hash table stores segment descriptors, and the second hash table stores page descriptors. This approach is more complex to implement, but it can be more efficient because the TLB can search for a match in two smaller hash tables instead of one larger hash table.

The specific approach that is used will depend on the specific implementation of the TLB and the MMU. However, both approaches are capable of handling both segment descriptors and page descriptors.
